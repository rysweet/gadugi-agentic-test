"use strict";
/**
 * GitHub Issue Reporter Agent
 *
 * Handles GitHub issue creation and management for test failures.
 * Supports issue deduplication, template-based creation, and comprehensive
 * GitHub API integration with rate limiting and error handling.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultIssueReporterConfig = exports.IssueReporter = void 0;
exports.createIssueReporter = createIssueReporter;
const rest_1 = require("@octokit/rest");
const crypto = __importStar(require("crypto"));
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("path"));
const logger_1 = require("../utils/logger");
const index_1 = require("./index");
/**
 * Default configuration values
 */
const DEFAULT_CONFIG = {
    timeout: 30000,
    rateLimitBuffer: 100,
    screenshotStorage: 'link',
    maxBodyLength: 65536,
    enableDeduplication: true,
    deduplicationLookbackDays: 30,
    issueTitleTemplate: '[TEST FAILURE] {{scenarioName}} - {{failureMessage}}',
    issueBodyTemplate: `## Test Failure Report

**Scenario:** {{scenarioName}} ({{scenarioId}})
**Failure Time:** {{timestamp}}
**Priority:** {{priority}}

### Error Details
\`\`\`
{{failureMessage}}
\`\`\`

{{#stackTrace}}
### Stack Trace
\`\`\`
{{stackTrace}}
\`\`\`
{{/stackTrace}}

### Reproduction Steps
{{#reproductionSteps}}
{{#each this}}
{{@index}}. {{this}}
{{/each}}
{{/reproductionSteps}}

### Environment Information
- **Platform:** {{systemInfo.platform}} {{systemInfo.arch}}
- **Node Version:** {{systemInfo.nodeVersion}}
{{#systemInfo.electronVersion}}
- **Electron Version:** {{systemInfo.electronVersion}}
{{/systemInfo.electronVersion}}
- **Working Directory:** {{systemInfo.workingDirectory}}

{{#screenshots}}
### Screenshots
{{#each this}}
- ![Screenshot]({{this}})
{{/each}}
{{/screenshots}}

{{#logs}}
### Relevant Logs
\`\`\`
{{#each this}}
{{this}}
{{/each}}
\`\`\`
{{/logs}}

---
*This issue was automatically generated by the Agentic Testing System*`,
    issueLabels: ['bug', 'test-failure', 'automated'],
    autoAssignUsers: [],
    createIssuesOnFailure: true,
    createPullRequestsForFixes: false
};
exports.defaultIssueReporterConfig = DEFAULT_CONFIG;
/**
 * GitHub Issue Reporter Agent
 *
 * Provides comprehensive GitHub integration for test failure reporting
 * and issue management with advanced features like deduplication,
 * template-based issue creation, and rate limiting.
 */
class IssueReporter {
    constructor(config) {
        this.name = 'IssueReporter';
        this.type = index_1.AgentType.GITHUB;
        this.rateLimitInfo = null;
        this.issueTemplates = new Map();
        this.fingerprintCache = new Map();
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.logger = logger_1.logger.child({ component: 'IssueReporter' });
        // Initialize Octokit with configuration
        this.octokit = new rest_1.Octokit({
            auth: this.config.token,
            baseUrl: this.config.baseUrl,
            request: {
                timeout: this.config.timeout
            }
        });
        this.logger.info('IssueReporter initialized', {
            owner: this.config.owner,
            repository: this.config.repository,
            baseUrl: this.config.baseUrl || 'https://api.github.com'
        });
    }
    /**
     * Initialize the agent
     */
    async initialize() {
        try {
            // Verify GitHub API access
            await this.verifyAccess();
            // Load rate limit information
            await this.updateRateLimitInfo();
            // Load custom templates if specified
            if (this.config.templatesDir) {
                await this.loadCustomTemplates();
            }
            this.logger.info('IssueReporter initialized successfully');
        }
        catch (error) {
            this.logger.error('Failed to initialize IssueReporter', { error: error.message });
            throw error;
        }
    }
    /**
     * Execute scenario (not applicable for this agent)
     */
    async execute(scenario) {
        throw new Error('IssueReporter does not support direct scenario execution');
    }
    /**
     * Clean up resources
     */
    async cleanup() {
        this.fingerprintCache.clear();
        this.issueTemplates.clear();
        this.logger.info('IssueReporter cleaned up');
    }
    /**
     * Create a GitHub issue from a test failure
     */
    async createIssue(failure) {
        this.logger.info('Creating GitHub issue for test failure', {
            scenarioId: failure.scenarioId,
            category: failure.category
        });
        try {
            // Check rate limits
            await this.checkRateLimit();
            // Check for duplicates if enabled
            if (this.config.enableDeduplication) {
                const existingIssue = await this.findDuplicates(failure);
                if (existingIssue) {
                    this.logger.info('Duplicate issue found, updating instead of creating', {
                        issueNumber: existingIssue.number
                    });
                    await this.addComment(existingIssue.number, `## Additional Occurrence\n\n**Timestamp:** ${failure.timestamp.toISOString()}\n\nThis failure occurred again with the same fingerprint.`);
                    return {
                        issueNumber: existingIssue.number,
                        url: existingIssue.html_url
                    };
                }
            }
            // Generate issue content
            const issueOptions = await this.generateIssueContent(failure);
            // Create the issue
            const response = await this.octokit.rest.issues.create({
                owner: this.config.owner,
                repo: this.config.repository,
                ...issueOptions
            });
            this.logger.info('GitHub issue created successfully', {
                issueNumber: response.data.number,
                url: response.data.html_url
            });
            // Cache the fingerprint
            const fingerprint = this.generateFingerprint(failure);
            this.fingerprintCache.set(fingerprint.hash, fingerprint);
            return {
                issueNumber: response.data.number,
                url: response.data.html_url
            };
        }
        catch (error) {
            this.logger.error('Failed to create GitHub issue', {
                error: error.message,
                scenarioId: failure.scenarioId
            });
            throw error;
        }
    }
    /**
     * Update an existing GitHub issue
     */
    async updateIssue(issueNumber, update) {
        this.logger.info('Updating GitHub issue', { issueNumber });
        try {
            await this.checkRateLimit();
            await this.octokit.rest.issues.update({
                owner: this.config.owner,
                repo: this.config.repository,
                issue_number: issueNumber,
                ...update
            });
            this.logger.info('GitHub issue updated successfully', { issueNumber });
        }
        catch (error) {
            this.logger.error('Failed to update GitHub issue', {
                error: error.message,
                issueNumber
            });
            throw error;
        }
    }
    /**
     * Find duplicate issues for a test failure
     */
    async findDuplicates(failure) {
        if (!this.config.enableDeduplication) {
            return null;
        }
        this.logger.debug('Searching for duplicate issues', {
            scenarioId: failure.scenarioId
        });
        try {
            const fingerprint = this.generateFingerprint(failure);
            const lookbackDate = new Date();
            lookbackDate.setDate(lookbackDate.getDate() - this.config.deduplicationLookbackDays);
            // Search for recent issues with similar characteristics
            const searchQuery = `repo:${this.config.owner}/${this.config.repository} is:issue "${failure.scenarioId}" created:>=${lookbackDate.toISOString().split('T')[0]}`;
            const searchResponse = await this.octokit.rest.search.issuesAndPullRequests({
                q: searchQuery,
                sort: 'created',
                order: 'desc',
                per_page: 20
            });
            // Check each issue for matching fingerprint
            for (const issue of searchResponse.data.items) {
                if (issue.body && issue.body.includes(fingerprint.hash)) {
                    this.logger.debug('Found duplicate issue', {
                        issueNumber: issue.number,
                        fingerprint: fingerprint.hash
                    });
                    return issue;
                }
            }
            return null;
        }
        catch (error) {
            this.logger.warn('Failed to search for duplicate issues', {
                error: error.message
            });
            return null;
        }
    }
    /**
     * Add a comment to an existing issue
     */
    async addComment(issueNumber, comment) {
        this.logger.debug('Adding comment to issue', { issueNumber });
        try {
            await this.checkRateLimit();
            await this.octokit.rest.issues.createComment({
                owner: this.config.owner,
                repo: this.config.repository,
                issue_number: issueNumber,
                body: comment
            });
            this.logger.debug('Comment added successfully', { issueNumber });
        }
        catch (error) {
            this.logger.error('Failed to add comment to issue', {
                error: error.message,
                issueNumber
            });
            throw error;
        }
    }
    /**
     * Attach screenshots to an issue
     */
    async attachScreenshot(issueNumber, screenshotPath) {
        this.logger.debug('Attaching screenshot to issue', {
            issueNumber,
            screenshotPath
        });
        try {
            const screenshotData = await fs.readFile(screenshotPath);
            const filename = path.basename(screenshotPath);
            // Create a gist to host the screenshot (GitHub API doesn't support file uploads to issues)
            const gistResponse = await this.octokit.rest.gists.create({
                description: `Screenshot for issue #${issueNumber}`,
                public: false,
                files: {
                    [filename]: {
                        content: screenshotData.toString('base64')
                    }
                }
            });
            const screenshotUrl = `${gistResponse.data.html_url}#file-${filename.replace(/\./g, '-')}`;
            // Add comment with screenshot link
            await this.addComment(issueNumber, `## Screenshot Added\n\n![${filename}](${screenshotUrl})\n\n*Screenshot uploaded at ${new Date().toISOString()}*`);
            this.logger.debug('Screenshot attached successfully', {
                issueNumber,
                url: screenshotUrl
            });
            return screenshotUrl;
        }
        catch (error) {
            this.logger.error('Failed to attach screenshot', {
                error: error.message,
                issueNumber,
                screenshotPath
            });
            throw error;
        }
    }
    /**
     * Create a pull request for fixes
     */
    async createPullRequest(options) {
        this.logger.info('Creating pull request', {
            title: options.title,
            head: options.head,
            base: options.base
        });
        try {
            await this.checkRateLimit();
            const response = await this.octokit.rest.pulls.create({
                owner: this.config.owner,
                repo: this.config.repository,
                ...options
            });
            this.logger.info('Pull request created successfully', {
                prNumber: response.data.number,
                url: response.data.html_url
            });
            return {
                prNumber: response.data.number,
                url: response.data.html_url
            };
        }
        catch (error) {
            this.logger.error('Failed to create pull request', {
                error: error.message,
                title: options.title
            });
            throw error;
        }
    }
    /**
     * Link issues to each other
     */
    async linkIssues(issueNumber, relatedIssueNumbers, linkType = 'relates') {
        this.logger.debug('Linking issues', {
            issueNumber,
            relatedIssues: relatedIssueNumbers,
            linkType
        });
        try {
            const linkText = relatedIssueNumbers
                .map(num => `#${num}`)
                .join(', ');
            const comment = `## Related Issues\n\nThis issue ${linkType} ${linkText}`;
            await this.addComment(issueNumber, comment);
            this.logger.debug('Issues linked successfully', { issueNumber });
        }
        catch (error) {
            this.logger.error('Failed to link issues', {
                error: error.message,
                issueNumber
            });
            throw error;
        }
    }
    /**
     * Assign users to an issue
     */
    async assignUsers(issueNumber, assignees) {
        this.logger.debug('Assigning users to issue', {
            issueNumber,
            assignees
        });
        try {
            await this.checkRateLimit();
            await this.octokit.rest.issues.addAssignees({
                owner: this.config.owner,
                repo: this.config.repository,
                issue_number: issueNumber,
                assignees
            });
            this.logger.debug('Users assigned successfully', {
                issueNumber,
                assignees
            });
        }
        catch (error) {
            this.logger.error('Failed to assign users', {
                error: error.message,
                issueNumber,
                assignees
            });
            throw error;
        }
    }
    /**
     * Set milestone for an issue
     */
    async setMilestone(issueNumber, milestoneNumber) {
        this.logger.debug('Setting milestone for issue', {
            issueNumber,
            milestoneNumber
        });
        try {
            await this.updateIssue(issueNumber, {
                milestone: milestoneNumber
            });
            this.logger.debug('Milestone set successfully', {
                issueNumber,
                milestoneNumber
            });
        }
        catch (error) {
            this.logger.error('Failed to set milestone', {
                error: error.message,
                issueNumber,
                milestoneNumber
            });
            throw error;
        }
    }
    /**
     * Get current rate limit information
     */
    async getRateLimitInfo() {
        try {
            const response = await this.octokit.rest.rateLimit.get();
            const rateLimit = response.data.rate;
            return {
                limit: rateLimit.limit,
                used: rateLimit.used,
                remaining: rateLimit.remaining,
                reset: new Date(rateLimit.reset * 1000)
            };
        }
        catch (error) {
            this.logger.error('Failed to get rate limit info', { error: error.message });
            throw error;
        }
    }
    /**
     * Generate issue fingerprint for deduplication
     */
    generateFingerprint(failure) {
        const fingerprintData = {
            scenarioId: failure.scenarioId,
            errorMessage: failure.message,
            category: failure.category || 'unknown'
        };
        // Include stack trace hash if available
        let stackTraceHash;
        if (failure.stackTrace) {
            stackTraceHash = crypto
                .createHash('md5')
                .update(failure.stackTrace)
                .digest('hex')
                .substring(0, 8);
        }
        const hash = crypto
            .createHash('sha256')
            .update(JSON.stringify(fingerprintData))
            .digest('hex')
            .substring(0, 16);
        return {
            ...fingerprintData,
            stackTraceHash,
            hash
        };
    }
    /**
     * Generate issue content from test failure
     */
    async generateIssueContent(failure) {
        const systemInfo = await this.getSystemInfo();
        const templateVars = {
            scenarioId: failure.scenarioId,
            scenarioName: failure.scenarioId, // Could be enhanced with actual scenario name
            failureMessage: failure.message,
            stackTrace: failure.stackTrace,
            timestamp: failure.timestamp.toISOString(),
            environment: process.env,
            screenshots: failure.screenshots,
            logs: failure.logs,
            reproductionSteps: this.generateReproductionSteps(failure),
            systemInfo: systemInfo,
            priority: this.determinePriority(failure),
            category: failure.category
        };
        const title = this.renderTemplate(this.config.issueTitleTemplate, templateVars);
        const body = this.renderTemplate(this.config.issueBodyTemplate, templateVars);
        // Add fingerprint to body for deduplication
        const fingerprint = this.generateFingerprint(failure);
        const bodyWithFingerprint = `${body}\n\n<!-- fingerprint:${fingerprint.hash} -->`;
        return {
            title,
            body: this.truncateBody(bodyWithFingerprint),
            labels: [...(this.config.issueLabels || []), this.determinePriorityLabel(failure)],
            assignees: this.config.autoAssignUsers
        };
    }
    /**
     * Render template with variables
     */
    renderTemplate(template, vars) {
        let rendered = template;
        // Simple template rendering (could be enhanced with a proper template engine)
        Object.entries(vars).forEach(([key, value]) => {
            if (value !== undefined && value !== null) {
                if (typeof value === 'object') {
                    rendered = rendered.replace(new RegExp(`{{${key}\\.(\\w+)}}`, 'g'), (match, prop) => {
                        return value[prop] || match;
                    });
                }
                else if (Array.isArray(value)) {
                    // Handle array rendering
                    rendered = rendered.replace(new RegExp(`{{#${key}}}([\\s\\S]*?){{/${key}}}`, 'g'), (match, content) => {
                        if (value.length === 0)
                            return '';
                        return value.map(item => content.replace(/{{this}}/g, item)).join('');
                    });
                }
                else {
                    rendered = rendered.replace(new RegExp(`{{${key}}}`, 'g'), String(value));
                }
            }
        });
        // Handle conditional blocks
        rendered = rendered.replace(/{{#(\w+)}}([\s\S]*?){{\/\1}}/g, (match, key, content) => {
            const value = vars[key];
            return (value && ((Array.isArray(value) && value.length > 0) || (!Array.isArray(value) && value !== '')))
                ? content
                : '';
        });
        return rendered;
    }
    /**
     * Generate reproduction steps from failure
     */
    generateReproductionSteps(failure) {
        const steps = [
            `Run test scenario: ${failure.scenarioId}`,
            'Execute the test steps as defined in the scenario'
        ];
        if (failure.failedStep !== undefined) {
            steps.push(`Failure occurs at step ${failure.failedStep + 1}`);
        }
        if (failure.category) {
            steps.push(`Note: This is a ${failure.category} type failure`);
        }
        return steps;
    }
    /**
     * Determine issue priority from failure
     */
    determinePriority(failure) {
        if (failure.category === 'critical' || failure.message.toLowerCase().includes('critical')) {
            return 'Critical';
        }
        else if (failure.message.toLowerCase().includes('error')) {
            return 'High';
        }
        else {
            return 'Medium';
        }
    }
    /**
     * Determine priority label
     */
    determinePriorityLabel(failure) {
        const priority = this.determinePriority(failure);
        return `priority:${priority.toLowerCase()}`;
    }
    /**
     * Get system information
     */
    async getSystemInfo() {
        return {
            platform: process.platform,
            arch: process.arch,
            nodeVersion: process.version,
            electronVersion: process.versions.electron,
            timestamp: new Date().toISOString(),
            workingDirectory: process.cwd(),
            environment: {
                NODE_ENV: process.env.NODE_ENV || 'unknown',
                CI: process.env.CI || 'false'
            }
        };
    }
    /**
     * Truncate body to maximum length
     */
    truncateBody(body) {
        if (body.length <= this.config.maxBodyLength) {
            return body;
        }
        const truncated = body.substring(0, this.config.maxBodyLength - 100);
        return `${truncated}\n\n...\n\n*Content truncated due to length limit*`;
    }
    /**
     * Verify GitHub API access
     */
    async verifyAccess() {
        try {
            await this.octokit.rest.repos.get({
                owner: this.config.owner,
                repo: this.config.repository
            });
            this.logger.info('GitHub API access verified');
        }
        catch (error) {
            this.logger.error('GitHub API access verification failed', {
                error: error.message
            });
            throw new Error(`GitHub API access failed: ${error.message}`);
        }
    }
    /**
     * Update rate limit information
     */
    async updateRateLimitInfo() {
        try {
            this.rateLimitInfo = await this.getRateLimitInfo();
            this.logger.debug('Rate limit info updated', this.rateLimitInfo);
        }
        catch (error) {
            this.logger.warn('Failed to update rate limit info', { error: error.message });
        }
    }
    /**
     * Check rate limit and wait if necessary
     */
    async checkRateLimit() {
        if (!this.rateLimitInfo) {
            await this.updateRateLimitInfo();
        }
        if (this.rateLimitInfo && this.rateLimitInfo.remaining <= this.config.rateLimitBuffer) {
            const waitTime = this.rateLimitInfo.reset.getTime() - Date.now();
            if (waitTime > 0) {
                this.logger.warn('Rate limit approaching, waiting for reset', {
                    remaining: this.rateLimitInfo.remaining,
                    resetTime: this.rateLimitInfo.reset.toISOString(),
                    waitTimeMs: waitTime
                });
                await new Promise(resolve => setTimeout(resolve, waitTime + 1000));
                await this.updateRateLimitInfo();
            }
        }
    }
    /**
     * Load custom templates from directory
     */
    async loadCustomTemplates() {
        if (!this.config.templatesDir) {
            return;
        }
        try {
            const templateDir = this.config.templatesDir;
            const files = await fs.readdir(templateDir);
            for (const file of files) {
                if (file.endsWith('.md') || file.endsWith('.txt')) {
                    const templateName = path.basename(file, path.extname(file));
                    const templatePath = path.join(templateDir, file);
                    const content = await fs.readFile(templatePath, 'utf-8');
                    this.issueTemplates.set(templateName, content);
                    this.logger.debug('Loaded custom template', {
                        name: templateName,
                        path: templatePath
                    });
                }
            }
        }
        catch (error) {
            this.logger.warn('Failed to load custom templates', {
                error: error.message,
                templatesDir: this.config.templatesDir
            });
        }
    }
}
exports.IssueReporter = IssueReporter;
/**
 * Create an IssueReporter agent instance
 */
function createIssueReporter(config) {
    return new IssueReporter(config);
}
//# sourceMappingURL=IssueReporter.js.map