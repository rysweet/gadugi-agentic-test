/**
 * ConfigurationLoader
 * Default config factory and file-based config loading logic extracted from lib.ts.
 */

import { pathExists } from 'fs-extra';
import { TestConfig } from '../models/Config';
import { logger } from '../utils/logger';
import { loadConfigFromFile } from '../utils/config';

/**
 * Command line arguments interface used by loadConfiguration
 */
export interface CliArguments {
  config: string;
  suite: 'smoke' | 'full' | 'regression';
  dryRun: boolean;
  noIssues: boolean;
  logLevel: 'DEBUG' | 'INFO' | 'WARNING' | 'ERROR';
  output?: string;
  parallel?: number;
  timeout?: number;
  scenarioFiles?: string[];
  verbose: boolean;
  debug: boolean;
}

/**
 * Build a complete default TestConfig from environment variables and safe defaults.
 */
export function createDefaultConfig(): TestConfig {
  // Filter out undefined env values to match Record<string, string>
  const envVars: Record<string, string> = Object.entries(process.env).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) acc[key] = value;
      return acc;
    },
    {} as Record<string, string>
  );

  const defaultConfig: TestConfig = {
    execution: {
      maxParallel: 3,
      defaultTimeout: 300000,
      continueOnFailure: true,
      maxRetries: 2,
      retryDelay: 1000,
      randomizeOrder: false,
      resourceLimits: {
        maxMemory: 1024 * 1024 * 1024, // 1 GB
        maxCpuUsage: 80,
        maxDiskUsage: 1024 * 1024 * 1024, // 1 GB
        maxExecutionTime: 600000, // 10 minutes
        maxOpenFiles: 100
      },
      cleanup: {
        cleanupAfterEach: true,
        cleanupAfterAll: true,
        cleanupDirectories: ['./temp', './screenshots'],
        cleanupFiles: ['*.tmp', '*.log'],
        terminateProcesses: [],
        stopServices: [],
        customCleanupScripts: []
      }
    },
    cli: {
      executablePath: 'uv run atg',
      workingDirectory: process.cwd(),
      defaultTimeout: 30000,
      environment: { NODE_ENV: 'test', ...envVars },
      captureOutput: true,
      shell: process.platform === 'win32' ? 'cmd.exe' : '/bin/bash',
      maxRetries: 2,
      retryDelay: 1000
    },
    ui: {
      browser: 'chromium',
      headless: true,
      viewport: { width: 1280, height: 720 },
      baseUrl: 'http://localhost:3000',
      defaultTimeout: 30000,
      screenshotDir: './outputs/screenshots',
      recordVideo: false,
      slowMo: 100
    },
    tui: {
      terminal: 'xterm',
      defaultDimensions: { width: 80, height: 24 },
      encoding: 'utf8',
      defaultTimeout: 30000,
      pollingInterval: 100,
      captureScreenshots: true,
      recordSessions: false,
      colorMode: '24bit',
      interpretAnsi: true,
      shell: process.platform === 'win32' ? 'cmd.exe' : '/bin/bash',
      shellArgs: [],
      environment: envVars,
      workingDirectory: process.cwd(),
      accessibility: { highContrast: false, largeText: false, screenReader: false },
      performance: {
        refreshRate: 60,
        maxBufferSize: 1024 * 1024, // 1 MB
        hardwareAcceleration: false
      }
    },
    github: {
      token: process.env.GITHUB_TOKEN || '',
      owner: process.env.GITHUB_OWNER || '',
      repository: process.env.GITHUB_REPOSITORY || '',
      baseBranch: 'main',
      createIssuesOnFailure: false,
      issueLabels: ['bug', 'automated-test'],
      issueTitleTemplate: 'Test Failure: {{scenario.name}}',
      issueBodyTemplate: `
# Test Failure Report

**Scenario:** {{scenario.name}}
**Test ID:** {{scenario.id}}
**Failure Time:** {{failure.timestamp}}

## Error Details
{{failure.message}}

## Stack Trace
\`\`\`
{{failure.stackTrace}}
\`\`\`

## Reproduction Steps
{{scenario.steps}}

---
*This issue was automatically generated by the Agentic Testing System*
      `.trim(),
      createPullRequestsForFixes: false,
      autoAssignUsers: []
    },
    priority: {
      enabled: true,
      executionOrder: ['critical', 'high', 'medium', 'low'],
      failFastOnCritical: true,
      maxParallelByPriority: { critical: 1, high: 2, medium: 3, low: 5 },
      timeoutMultipliers: { critical: 2.0, high: 1.5, medium: 1.0, low: 0.8 },
      retryCountsByPriority: { critical: 3, high: 2, medium: 1, low: 0 }
    },
    logging: {
      level: 'info',
      console: true,
      format: 'structured',
      includeTimestamp: true,
      maxFileSize: 10 * 1024 * 1024, // 10 MB
      maxFiles: 5,
      compress: true
    },
    reporting: {
      outputDir: './outputs/reports',
      formats: ['html', 'json'],
      includeScreenshots: true,
      includeLogs: true,
      customTemplates: {},
      generationTimeout: 30000
    },
    notifications: {
      enabled: false,
      channels: [],
      triggers: [],
      templates: {}
    },
    plugins: {}
  };

  return defaultConfig;
}

/**
 * Load TestConfig from a YAML file, merging CLI overrides and environment
 * variables on top. Falls back to createDefaultConfig() on any error.
 */
export async function loadConfiguration(
  configPath: string,
  cliArgs: Partial<CliArguments>
): Promise<TestConfig> {
  let config: TestConfig;

  if (await pathExists(configPath)) {
    logger.info(`Loading configuration from: ${configPath}`);
    try {
      config = await loadConfigFromFile(configPath);
    } catch (error) {
      logger.warn(`Failed to load config from ${configPath}, using defaults:`, error);
      config = createDefaultConfig();
    }
  } else {
    logger.warn(`Config file not found: ${configPath}, using defaults`);
    config = createDefaultConfig();
  }

  // CLI overrides
  if (cliArgs.noIssues && config.github) {
    config.github.createIssuesOnFailure = false;
  }
  if (cliArgs.parallel) {
    config.execution.maxParallel = cliArgs.parallel;
  }
  if (cliArgs.timeout) {
    config.execution.defaultTimeout = cliArgs.timeout;
  }
  if (cliArgs.logLevel) {
    config.logging.level = cliArgs.logLevel.toLowerCase() as 'debug' | 'info' | 'warn' | 'error';
  }

  // Environment variable overrides for GitHub config
  if (config.github) {
    config.github.token      = process.env.GITHUB_TOKEN      || config.github.token;
    config.github.owner      = process.env.GITHUB_OWNER      || config.github.owner;
    config.github.repository = process.env.GITHUB_REPOSITORY || config.github.repository;
  }

  return config;
}
